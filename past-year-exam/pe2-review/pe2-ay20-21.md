# PE2 (AY20/21)

## Problems

### 1. Tic Tac Toe

An easy probelm, just break this problem into several small problems and solve it.

### 2. Sun

The whole idea is to find the max num (index) that provides the biggest "triangle" number smaller than the input `n`. And then we start from that triangle number to find its corresponding prime partner. (Cuz the probelms says triangle num should be in decreasing order)

{% code lineNumbers="true" %}
```c
for (max = 0; tri <= n; max += 1)
{
  tri = max * (max + 1) / 2;
}
for (long x = max - 2; x >= 0; x -= 1)
{
  tri = x * (x + 1) / 2;
  if (is_prime(n - tri))
  {
    cs1010_print_long(n - tri);
    cs1010_print_string(" ");
    cs1010_println_long(tri);
  }
}
```
{% endcode %}

But the overall run time of $$O(N)$$ is a bit tricky. Here our first loop is actually $$O(\sqrt{N})$$ and our second loop is actually one $$O(\sqrt{N})$$ loop inside another $$O(\sqrt{N})$$ loop, so the overal timing is $$O(N)+O(\sqrt{N})$$, which is $$O(N)$$

### 3. Replace\*

#### The official answer

The idea of **replacing** the **redundant chars** in the target string **with white spaces** and then **ignore them in the final print** is awesome.

{% code title="Substitute.c" lineNumbers="true" %}
```c
void substitute(char *word, size_t i, size_t target_len, char *replace_with) {
    size_t replace_len = strlen(replace_with);
    size_t j = 0;
    while (j < replace_len) {
        word[i + j] = replace_with[j];
        j += 1;
    }
    while (j < target_len) {
        word[i + j] = ' ';
        j += 1;
    }
}
```
{% endcode %}

There is an awesome idea here! The use of `i` to indicate the start position in the source string we want to search for deals with the moving problem of the string successfully.

{% hint style="info" %}
Here it is assumed that the length of the target string is **longer than or equal to** the length of the replace string.
{% endhint %}

{% code title="Compact.c" lineNumbers="true" %}
```c
void compact(char *word)
{
    size_t src = 0;
    size_t dst = 0;
    size_t word_len = strlen(word);
    while (src < word_len) {
        if (word[src] != ' ') {
            word[dst] = word[src];
            dst += 1;
        }
        src += 1;
    }
    word[dst] = 0;
}
```
{% endcode %}

{% hint style="info" %}
Based on the same assumption above, our `dst` is always smaller than or equal to `src`
{% endhint %}

{% code title="Replace.c" lineNumbers="true" %}
```c
void replace(char *word, char *search_for, char *replace_with)
{
    size_t word_len = strlen(word);
    size_t search_len = strlen(search_for);
    for (size_t i = 0余 i < word_len余 i += 1) {
        if (is_match(word, i, search_for)) {
            substitute(word, i, search_len, replace_with);
            i += search_len 足- 1;
        }
    }
    compact(word)余
}
```
{% endcode %}

#### My Recursive solution

Refer to the idea of doing recursion on strings from past year final paper (AY21/22 Q19) I implement a recursive solution as follows:

{% code overflow="wrap" lineNumbers="true" %}
```c
void search_and_replace(char *tar, char *rep, long tar_len, long rep_len, char *res, char *source)
{
  long len_res = 0;
  long len_src = 0;
  if (*source == '\0')
  {
    return;
  }
  long start_pos = find_pos(tar, source);
  if (start_pos != -1)
  {
    for (long i = 0; i < start_pos; i += 1)
    {
      res[i] = source[i];
    }
    len_res += start_pos; 
    for(long i = 0; i < rep_len; i += 1)
    {
      res[i+len_res] = rep[i];
    }
    len_res += rep_len;
    len_src = start_pos + tar_len;
  }
  else
  {
    char *temp = source;
    while (*temp != '\0')
    {
      res[len_src] = source[len_src];
      len_src += 1;
      temp += 1;
    }
    len_res = len_src;
   }
  search_and_replace(tar, rep, tar_len, rep_len, res+len_res, source+len_src);
}
```
{% endcode %}

Note that this function will need some tedious memory management in the `main()` function, where we need to read several target strings and replacement strings.

### 4. Soil

Prof summarises this problem to be a **pattern recognition** problem. The soul of this problem is the narrow your "searching area". That is, we can start from top-right (`a[0][n-1]`)

1. If `a[0][n-1]` is bigger than `q`, that means `q` cannot exist in the **last column**, so we narrow our search area by excluding the last column.
2. If `a[0][n-1]` is smaller than `q`, that means `q` cannot exist in the **first row,** so we narrow our search area by excluding the first row.

## Tips

1. Somtimes changing the **loop condition** will change the obvious time complexity, pay attention to the "hidden" time complexity and sometimes this kind of change can be utilised to make your code more effificient.
2. When you want to improve the complexity of **searching/sorting** problems, try thinking about how to **narrow your "searching area"**. This will be very useful!
