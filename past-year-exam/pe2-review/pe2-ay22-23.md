# PE2 (AY22/23)

## Problems

### 1. Search

This is just a give-away question. Follow the instructions strictly will let you pass!

### 2. Missing

This can also be regarded as a give-away question. It just uses **counting sort!**

### **3. Group\***

> This question is a variant of [#id-5.-stone](../midterm-pe/pe1-ay21-22.md#id-5.-stone "mention"), but the given solution provides a genius way to print out the result using array

The key idea to solve this question is to draw a "tree", more details are discussed in [lab-09-backtracking.md](../../lec-tut-lab-exes/lab/lab-09-backtracking.md "mention").

But let's see how genius the answer is:

{% code lineNumbers="true" %}
```c
void group(size_t current, size_t num_groups, size_t students[], size_t n)
{
  if (current == n)
  {
    print(students, n);
    return;
  }
  // put current student in one of the exisitng groups
  for (size_t i = 1; i <= num_groups; i += 1)
  {
    students[current] = i;
    group(current + 1, num_groups, students, n);
  }
  // or start new group
  students[current] = num_groups + 1;
  group(current + 1, num_groups + 1, students, n);
}
```
{% endcode %}

By overwriting the value of `students[current]`, we are actually doing our "back-tracking"! And once we have reached the end element, we print out the whole array. And our main should look like below:

{% code lineNumbers="true" %}
```c
int main()
{
  size_t n = cs1010_read_size_t();
  size_t *students = calloc(n, sizeof(size_t));
  if (students == NULL)
  {
    return 1;
  }
  // start with num_groups 0
  group(0, 0, students, n);
  free(students);
}
```
{% endcode %}

## Tips

1. Refer back to [lab-09-backtracking.md](../../lec-tut-lab-exes/lab/lab-09-backtracking.md "mention") when doing the backtracking problems! Usually, an easier way to help you understand is to **draw a "tree"**.
